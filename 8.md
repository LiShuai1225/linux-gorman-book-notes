# Chapter 8: Slab Allocator

* The kernel's 'general purpose' allocator is a 'slab allocator'. The basic
  concept is to have caches of commonly used objects kept in an initialised
  state, available for use by the kernel.

* Without an object-based allocator, the kernel would spend a lot of the time
  allocating, initialising and freeing the same object over and over again - the
  slab allocator aims to cache freed objects so they can be reused.

* The slab allocator consists of a variable number of caches linked together on
  a doubly-linked circular list called a 'cache chain'.

* In the context of the slab allocator a cache is a manager for a number of
  objects of a particular type, e.g. a [struct mm_struct][mm_struct] cache, each
  of which are managed by a [struct kmem_cache_s][kmem_cache_s].

* Each cache maintains blocks of contiguous pages in memory called 'slabs' that
are carved into small chunks for the objects that the cache manages:

```
-------------          ---------          -------------
| lastcache |--------->| cache |--------->| nextcache |
-------------          ---------          -------------
                        |  |  |
                        |  |  |
          /-------------/  |  \--------------\
          |                |                 |
          v                v                 v
   --------------  -----------------  --------------
   | slabs_full |  | slabs_partial |  | slabs_free |
   --------------  -----------------  --------------
          |                |                 |
          |                |                 |
          |                |                 |
          |                |                 |
          v                v                 v
      ---------        ---------         ---------
      | slabs |        | slabs |         | slabs |
      ---------        ---------         ---------
          |                |                 |
          |                |                 |
          |                |                 |
          |                |                 |
          v                v                 v
      ---------        ---------         ---------
      | pages |        | pages |         | pages |
      ---------        ---------         ---------
          |                |                 |
          |                |                 |
      /-------\        /-------\         /-------\
      |       |        |       |         |       |
      v       v        v       v         v       v
   ------- -------  ------- -------   ------- -------
   | obj | | obj |  | obj | | obj |   | obj | | obj |
   ------- -------  ------- -------   ------- -------
```

* The slab allocator has 3 principle aims:

1. The allocation of small blocks of memory to help eliminate internal
   fragmentation that would be otherwise caused by the buddy system.

2. The caching of commonly used objects so the system does not waste time
   allocating, initialising and destroying objects.

3. Better use of the hardware cache by aligning objects to the L1 or L2 caches.

* To help eliminate internal fragmentation normally caused by a binary buddy
  allocator, two sets of caches of small memory buffers ranging from `2^5` (32)
  bytes to `2^17` (131,072) bytes are maintained.

* One cache set is suitable for use with DMA devices, the other not, these are
  called 'size-N(DMA)' and 'size-N' respectively, where N is the size of the
  allocation.

* The function [kmalloc()][kmalloc] is provided for allocating to these (see
  8.4.1.) Additionally, the sizes of the caches are discussed in further detail
  in 8.4.

* The slab allocator also maintains caches of commonly used objects - for many
  structures used in the kernel, the time needed to initialise an object is
  comparable with, or exceeds, the cost of allocating space for it.

* When a new slab is created, a number of objects are packed into it and
  initialised using a constructor if available. When an object is freed, it is
  left in its initialised state so that object allocation will be quick.

* The final task of the slab allocator is to optimise the use of hardware
  caches. In order to do this, 'slab colouring' is performed - if there is space
  left over after objects are packed into a slab, the remaining space is used to
  colour the slab.

* Slab colouring is a scheme that attempts to ensure that objects in different
  slabs use different lines in the cache. By placing objects at different
  starting offsets within the slab, they will likely use different lines int he
  CPU cache which helps ensure that objects from the same slab cache will be
  unlikely to flush each other.

* With this scheme, space that would otherwise be wasted is used to fulfil a new
  function. Diagrammatically:

```
                             ------------------
                             |                |
                             |                |
                             |                |
                             |                |
                             |  Rest of page  |
 ----------------------      |  filled with   |
 |   kmem_getpages()  |      |  objects and   |
 ----------------------      |    padding     |
            |                |                |
            |                |                |  ----------------------
            |                |                |  | kmem_cache_alloc() |
            v                |                |  ----------------------
 ----------------------      |----------------|             |
 | __get_free_pages() |      | Colour padding |             |
 ----------------------      |----------------|             |
            |                |                |<------------/
            |                |  Initialised   |                 -----------------------
            |                |     Object     |                 | Object allocated to |
            v                |                |---------------->| requesting process  |
 ----------------------      |----------------| ^               -----------------------
 |   Allocates pages  |      | Colour padding | |
 |      of order      |      |----------------| |
 | cachep->gfp_order  |      |                | |   L1 CPU
 ----------------------      |  Initialised   | | Cache Size
            |                |     Object     | |
            |                |                | |
            \--------------->|----------------- v
```

* Linux does not attempt to colour page allocations based on the physical
  address, or to order where objects are placed. The details of cache colours is
  discussed further in 8.1.5.

* On an SMP system, a further step is taken to help cache utilisation where each
  cache has a small array of objects reserved for each CPU - this is discussed
  in more detail in 8.5.

* The slab allocator allows for slab debugging if `CONFIG_SLAB_DEBUG` is
  set. This adds 'red zoning' and 'objection poisoning'.

* Red zoning adds a market at either end of the object - if it is disturbed the
  allocator knows which object encountered a buffer overflwo, and reports it.

* Poisoning an object will fill it with a predefined bit pattern
  ([POISON_BYTE][POISON_BYTE] which is defined as `0x5a`) at slab creation and
  after free. On each allocation this pattern is checked - if it is changed, the
  allocator knows the object was used before it was allocated, and flags it.

* Taking a look at the slab allocator's API:

1. [kmem_cache_create()][kmem_cache_create] - Creates a new cache and adds it to
   the cache chain.

2. [kmem_cache_reap()][kmem_cache_reap] - Scans at most
   [REAP_SCANLEN][REAP_SCANLEN] caches and selects one for reaping all per-CPU
   objects and free slabs from. This is called when memory is tight.

3. [kmem_cache_shrink()][kmem_cache_shrink] - Deletes all per-CPU objects
   associated with a cache and deletes all slabs in the
   `kmem_cache_s->slabs_free` list. It returns the number of freed pages.

4. [kmem_cache_alloc()][kmem_cache_alloc] (and subsequently
   [__kmem_cache_alloc()][__kmem_cache_alloc]) - Allocates a single object from
   the cache and returns it to the caller.

5. [kmem_cache_free()][kmem_cache_free] - Frees an object and returns it to the cache.

6. [kmalloc()][kmalloc] - Allocates a block of memory from one of the specified
   `size`s cache.

7. [kfree()][kfree] - Frees a block of memory allocated with `kmalloc()`.

8. [kmem_cache_destroy()][kmem_cache_destroy] - Destroys all objects in all
   slabs and frees up all associated memory before removing the cache from the
   chain.

[mm_struct]:http://fxr.watson.org/fxr/source/include/linux/sched.h?v=linux-2.4.22#L206
[kmem_cache_s]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L190
[kmalloc]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/slab.c#L1555
[POISON_BYTE]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L300
[kmem_cache_create]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L622
[kmem_cache_reap]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L1738
[REAP_SCANLEN]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L103
[kmem_cache_shrink]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L966
[kmem_cache_alloc]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L1529
[__kmem_cache_alloc]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L1338
[kmem_cache_free]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L1576
[kmalloc]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L1555
[kfree]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L1597
[kmem_cache_destroy]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L997
