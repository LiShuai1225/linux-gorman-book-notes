# Chapter 6: Physical Page Allocation

* Physical pages are managed using the 'binary buddy allocator', originally
  devised by Knowlton and further described by Knuth (TAocP Volume 1, Section
  2.5, pg. 442) and has shown to be extremely fast compared to other allocators
  (see David G. Korn and Kiem-Phong Bo. In search of a better malloc In
  Proceedings of the Summer 1985 USENIX Conference, pages 489â€“506, Portland, OR,
  1985.)

* This is an allocation scheme that combines a power-or-two allocator with free
  buffer coalescing.

* The concept behind a binary buddy allocator is quite simple:

1. Memory is broken up into large blocks of pages where each block is a power
   of 2 number of pages.

2. If a block of the desired size is not available a large block is broken up in
   half and the two blocks are considered 'buddies' to each other - one half is
   used for the allocation, the other is free.

3. The blocks are continuously halved as necessary until a block of the desired
   size is available.

4. When a block is freed the buddy is examined, and the two are coalesced if it
   is free.

## 6.1 Managing Free Blocks

* The allocator maintains blocks of free pages where each block is a
  power-of-two number of pages.

* The exponent of the power of 2 is referred to as its _order_.

* An array of [free_area_t][free_area_t] structs are maintained for each order
  each of which point to a linked list of blocks of pages that are free, e.g.:

```
order    free_area_t             Free page blocks
       zone->free_area
     |---------------|-|
|    |       0       | | -> [] -> [] -> ...       2^0 page-sized blocks
|    |---------------|-|
|    |       1       | |
|    |---------------|-|
|    |       2       | |
|    |---------------|-|
|    |       3       | |
|    |---------------|-|
|    |       4       | | -> [==] -> [==] -> ...   2^4 page-sized blocks
|    |---------------|-|
|    |       5       | |
|    |---------------|-|
|    |       6       | |
|    |---------------|-|
|    |       7       | |
|    |---------------|-|
|    |       8       | |
|    |---------------|-|
|    |       9       | | -> [==========] -> ...   2^(MAX_ORDER - 1) page-sized blocks
|    |---------------|-|
|    |   MAX_ORDER   | | (exclusive bound)
v    |---------------|-|
```

* [MAX_ORDER][MAX_ORDER] is currently set at 10 unless otherwise specified by
  `CONFIG_FORCE_MAX_ZONEORDER`. This eliminates the chance that a larger block
  will be split to satisfy a request where a smaller block would suffice.

* The page blocks are maintained on a linear linked list using
  [struct page][page]`->list`.

* Each zone has a [free_area_t][free_area_t] array field of `free_area[MAX_ORDER]`.

* Looking at `free_area_t` itself:

```c
typedef struct free_area_struct {
        struct list_head        free_list;
        unsigned long           *map;
} free_area_t;
```

* `free_list` is a linked list of free page blocks, `map` is a bitmap
  representing the state of a pair of buddies.

* Linux saves memory by using one bit instead of two to represent each pair of
  buddies - each time a buddy is allocated or freed, the bit representing the
  pair of biddues is toggled so that the bit is 0 if the pair of pages are both
  free or both full and 1 if only one buddy is in use.

* To toggle the correct bit, the macro [MARK_USED()][MARK_USED] is used:

```c
#define MARK_USED(index, order, area) \
        __change_bit((index) >> (1+(order)), (area)->map)
```

* `index` is the index of the page within the global [mem_map][mem_map] array.

* The correct bit to flip is determined by shifting `index` right by `1 +
  order` - this way two indexes next to one another will resolve to the same
  bit. The addition of 1 to the shift will ensure this happens for index 0 and 1
  too.

* [__change_bit()][__change_bit] ultimately uses the [btc][btc] 'bit test and
  complement' op-code.


[free_area_t]:http://fxr.watson.org/fxr/source/include/linux/mmzone.h?v=linux-2.4.22#L22
[MAX_ORDER]:http://fxr.watson.org/fxr/source/include/linux/mmzone.h?v=linux-2.4.22#L17
[page]:http://fxr.watson.org/fxr/source/include/linux/mm.h?v=linux-2.4.22#L154
[MARK_USED]:http://fxr.watson.org/fxr/source/mm/page_alloc.c?v=linux-2.4.22#L174
[mem_map]:http://fxr.watson.org/fxr/source/mm/memory.c?v=linux-2.4.22#L73
[__change_bit]:http://fxr.watson.org/fxr/source/include/asm-i386/bitops.h?v=linux-2.4.22#L90
[btc]:https://pdos.csail.mit.edu/6.828/2010/readings/i386/BTC.htm
