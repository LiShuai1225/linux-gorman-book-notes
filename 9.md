# Chapter 9: High Memory Management

* The kernel can only directly address memory for which it has set up a page
  table entry. In the common case, the user/kernel address space split of
  3GiB/1GiB implies that, at best, only 896MiB of memory may be directly
  accessed at any given time on a 32-bit machine (see 4.1)

* On 64-bit hardware this is not an issue as there are vast amounts of virtual
  address space, however 32-bit is another story.

* On 32-bit hardware Linux temporarily maps pages from high memory into the
  lower page tables (discussed further in 9.2.)

* In I/O operations, not all devices are able to address high memory or even all
  the memory available to the CPU (consider [PAE][pae].) Asking the device to
  write to memory will fail at best and fuck the kernel at worst. To work around
  this issue we can use a 'bounce buffer' which is discussed in 9.5.

## 9.1 Managing the PKMap Address Space

* The 'Persistent Kernel Map' (PKMap) address space is reserved at the top of
  the kernel page tables from [PKMAP_BASE][PKMAP_BASE] to
  [FIXADDR_START][FIXADDR_START].

* On i386, `PKMAP_BASE` is `0xfe000000`, and `FIXADDR_START` varies depending on
  configuration options, but is typically only a few pages from the end of the
  linear address space - this leaves us around 32MiB of page table space for
  mapping pages from high memory into usable space.

* For mapping pages, a single page set of PTEs is stored at the beginning of the
  PKMap area to allow 1,024 high pages to be mapped into low memory for short
  periods via [kmap()][kmap] and to be unmapped with [kunmap()][kunmap].

* The pool of 1,024 pages (4MiB) seems very small, however pages mapped by
  `kmap()` are only mapped for a _very_ short period of time.

* Comments in the code suggest that there was a plan to allocate contiguous page
  table entries to expand this area however this hasn't been performed in
  2.4.22, so a large portion of the PKMap is unused.

* The page table entry for use with `kmap()` is
  [pkmap_page_table][pkmap_page_table] and is located at
  [PKMAP_BASE][PKMAP_BASE] which is set up during system initialisation (on i386
  this takes place at the end of [pagetable_init()][pagetable_init].

* The pages for the PGD and PMD entries are allocated by the boot memory
  allocator to ensure they exist.

* The state of these page table entries is managed by
  [pkmap_count][pkmap_count], which has [LAST_PKMAP][LAST_PKMAP] entries in it -
  on i386 without PAE this is 1,024 and with PAE it is 512. More accurately,
  though the code doesn't make it clear, `LAST_PKMAP` is equivalent to
  [PTRS_PER_PTE][PTRS_PER_PTE/3lvl].

* Each element in `pkmap_count` is not exactly a reference count, but is very
  close - if the entry is 0, the page is free and has not been used since the
  last TLB flush. If it's 1, the slot is unused, but a page is still mapped
  there waiting for a TLB flush, and finally if it's any higher it has `n - 1`
  users, taking `n` to be the element value.

* Flushes are delayed until every slot has been used at least once because a
  global flush is required for all CPUs when the global page tables are modified
  and this is _extremely_ expensive.

[pae]:https://en.wikipedia.org/wiki/Physical_Address_Extension

[PKMAP_BASE]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/asm-i386/highmem.h#L49
[FIXADDR_START]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/asm-i386/fixmap.h#L106
[kmap]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/asm-i386/highmem.h#L62
[kunmap]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/asm-i386/highmem.h#L74
[pkmap_page_table]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/highmem.c#L38
[pagetable_init]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/arch/i386/mm/init.c#L205
[pkmap_count]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/highmem.c#L33
[LAST_PKMAP]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/asm-i386/highmem.h#L51
[PTRS_PER_PTE/3lvl]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/asm-i386/pgtable-3level.h#L27
