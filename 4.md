# Chapter 4: Process Address Space

* One of the major advantages of virtual memory is that each process has its own
  virtual address space, mapped to physical memory by the operating system.

* This chapter explores the address space as seen by a process, and how it is
  managed by linux.

* The kernel treats the userspace portion of the address space very differently
  from the kernel portion. For example, allocations for the kernel are satisfied
  immediately and are visible globally, no matter which process is current.

* An exception to this however is [vmalloc()][vmalloc] (and consequently
  [__vmalloc()][__vmalloc]), as it causes a minor page fault to occur to
  synchronise the process page tables with the reference page tables, however
  the page will still be allocated immediately upon request.

* For a process, space is simply reserved in the linear address space by
  pointing a page table entry to a read-only globally visible page filled with
  zeros.

* When the process tries to write to this table a page fault is triggered
  causing the kernel to allocate a new zeroed page and assign it to the PTE and
  mark it writeable. It's zeroed so it appears precisely the same as the global
  zero-filled page.

* The userspace portion of virtual memory is not trusted nor presumed
  constant. After each context switch, the userspace portion of the linear
  address space can change except when a 'Lazy TLB' switch is used (discussed in
  4.3.)

* As a result, the kernel has to be configured to catch all exceptions and
  address errors raised from userspace (discussed in 4.5.)

## 4.1 Linear Address Space

* From a user perspective, the address space is a flat, linear address
  space. The kernel's view is rather different - the address space is split
  between userspace which potentially changes on context switch and the kernel
  address space which remains constant.

* The split is determined by the value of [PAGE_OFFSET][PAGE_OFFSET] (==
  [__PAGE_OFFSET][__PAGE_OFFSET]) - 0xc0000000 on i386 - meaning that 3GiB is
  available for the process to use while the remaining 1GiB is always mapped by
  the kernel.

* Diagramatically the kernel address space looks as follows:

```
            0 -> |-----------------|                  ^                 ^
                 |     Process     |                  |                 |
                 |     Address     |                  |                 |
                 |      Space      |                  |                 |
                 /        .        /                  | TASK_SIZE       |
                 \        .        \                  |                 |
                 /        .        /                  |                 |
                 |                 |                  |                 |
  PAGE_OFFSET -> |-----------------|                  X                 |
                 |      Kernel     |                  | Physical        |
                 |      Image      |                  | Memory Map      |
                 |-----------------|                  |                 |
                 |   struct page   |                  | (Depends on #   | Linear Address
                 |  Map (mem_map)  |                  |  physical RAM)  | Space
                 |-----------------| ^                v                 | (2^BITS_PER_LONG bytes)
                 |    Pages Gap    | | VMALLOC_OFFSET                   |
VMALLOC_START -> |-----------------| v                ^                 |
                 |     vmalloc     |                  |                 |
                 |  Address Space  |                  |                 |
  VMALLOC_END -> |-----------------| ^                |                 |
                 |    Pages Gap    | | 2 * PAGE_SIZE  |                 |
   PKMAP_BASE -> |-----------------| X                |                 |
                 |      kmap       | | LAST_PKMAP *   | VMALLOC_RESERVE |
                 |  Address Space  | | PAGE_SIZE      | at minimum      |
FIXADDR_START -> |-----------------| X                |                 |
                 |  Fixed Virtual  | | __FIXADDR_SIZE |                 |
                 | Address Mapping | |                |                 |
  FIXADDR_TOP -> |-----------------| v                |                 |
                 |    Page Gap     |                  |                 |
                 |-----------------|                  v                 v
```

* To load the kernel image, 8MiB (the amount of memory addressed by two PGDs) is
  reserved at `PAGE_OFFSET`. The kernel image is placed in this reserved space
  during kernel page table initialisation as discussed in 3.6.1.

* Somewhere shortly after the image, the [mem_map][mem_map] for UMA
  architectures (as discussed in chapter 2) is stored. The location is usually at
  the 16MiB mark to avoid using `ZONE_DMA`, but not always.

* For NUMA architectures, portions of the virtual `mem_map` will be scattered
  throughout this region and where they are actually located is architecture
  dependent.

* The region between `PAGE_OFFSET` and `VMALLOC_START - VMALLOC_OFFSET`, is the
  'physical memory map' and the size of the region depends on the amount of
  available physical RAM.

* Between the physical memory map and the vmalloc address space there is a gap
  `VMALLOC_OFFSET` in size (8MiB on i386) used to guard against out-of-bound
  errors.

* As an example, an i386 system with 32MiB of RAM with have `VMALLOC_START`
  located at `PAGE_OFFSET + 0x02000000 + 0x00800000` (i.e. `PAGE_OFFSET` +
  32MiB + 8MiB.)

* In low-memory systems, the remaining amount of the virtual address space,
  minus a 2 page gap, is used by [vmalloc()][vmalloc] for representing
  non-contiguous memory allocations in a contiguous virtual address space.

* In high-memory systems, the `vmalloc` area extends as far as `PKMAP_BASE`
  minus the two-page gap, and two extra regions are introduced - kmap and fixed
  virtual address mappings.

* The `kmap` region, which begins at [PKMAP_BASE][PKMAP_BASE], is reserved for
  the mapping of high memory pages into low memory via [kmap()][kmap] (and
  subsequently [__kmap()][__kmap].) We'll go into this in more detail in chapter
  9.

* The fixed virtual address mapping region, which begins at
  [FIXADDR_START][FIXADDR_START] and ends at [FIXADDR_TOP][FIXADDR_TOP], is used
  by subsystems that need to know the virtual address of a mapping at compile
  time, e.g. [APIC][apic] mappings.

* On i386, `FIXADDR_TOP` is statically defined to be `0xffffe000`, which is one
  page prior to the end of the virtual address space. The size of this region is
  calculated at compile time via [__FIXADDR_SIZE][__FIXADDR_SIZE] and used to
  index back from `FIXADDR_TOP` to give the start of the region,
  `FIXADDR_START`.

* The region required for [vmalloc()][vmalloc], [kmap()][kmap] and the fixed
virtual address mappings is what limits the size of `ZONE_NORMAL`.

* As the running kernel requires these functions, a region of at least
  [VMALLOC_RESERVE][VMALLOC_RESERVE] (which is aliased to
  [__VMALLOC_RESERVE][__VMALLOC_RESERVE]) is reserved at the top of the address
  space.

* `VMALLOC_RESERVE` is architecture-dependent, but on i386 it's defined as
  128MiB. This explains why `ZONE_NORMAL` is generally considered to be only
  896MiB in size - it's the 1GiB of the upper portion of the linear address
  space minus the minimum 128MiB that is reserved for the vmalloc region.

[vmalloc]:http://fxr.watson.org/fxr/source/include/linux/vmalloc.h?v=linux-2.4.22#L37
[__vmalloc]:http://fxr.watson.org/fxr/source/mm/vmalloc.c?v=linux-2.4.22#L261
[PAGE_OFFSET]:http://fxr.watson.org/fxr/source/include/asm-i386/page.h?v=linux-2.4.22#L128
[__PAGE_OFFSET]:http://fxr.watson.org/fxr/source/include/asm-i386/page.h?v=linux-2.4.22#L81
[mem_map]:http://fxr.watson.org/fxr/source/mm/memory.c?v=linux-2.4.22#L73
[PKMAP_BASE]:http://fxr.watson.org/fxr/source/include/asm-i386/highmem.h?v=linux-2.4.22#L49
[kmap]:http://fxr.watson.org/fxr/source/include/asm-i386/highmem.h?v=linux-2.4.22#L62
[__kmap]:http://fxr.watson.org/fxr/source/include/asm-i386/highmem.h?v=linux-2.4.22#L65
[FIXADDR_START]:http://fxr.watson.org/fxr/source/include/asm-i386/fixmap.h?v=linux-2.4.22#L106
[FIXADDR_TOP]:http://fxr.watson.org/fxr/source/include/asm-i386/fixmap.h?v=linux-2.4.22#L104
[apic]:https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller
[__FIXADDR_SIZE]:http://fxr.watson.org/fxr/source/include/asm-i386/fixmap.h?v=linux-2.4.22#L105
[VMALLOC_RESERVE]:http://fxr.watson.org/fxr/source/include/asm-i386/page.h?v=linux-2.4.22#L129
[__VMALLOC_RESERVE]:http://fxr.watson.org/fxr/source/include/asm-i386/page.h?v=linux-2.4.22#L87
