# Chapter 10: Page Frame Reclamation

* A running system will eventually use all available page frames for disk
  buffers, [struct dentry][dentry]s, [struct inode][inode]s, process pages,
  etc. etc.

* Linux needs to select old pages that can be freed and invalidated for new uses
  before physical memory becomes exhausted - this chapter focuses on how linux
  implements its 'page replacement policy' and how different types of pages are
  invalidated.

* The way linux selects pages is rather empirical and contains a mix of ideas
  moderated by user feedback and benchmarks.

* The page cache is a cache of all data that is read from disk to reduce the
  amount of disk I/O required. Strictly speaking this is not directly related to
  page frame reclamation, however the LRU lists and page cache are closely related.

* With the exception of the slab allocator, all pages in use by the system are
  stored on [LRU][lru] lists and linked together via [struct page][page]`->lru`
  so they can be easily scanned for replacement.

* The slab pages are not stored on the LRU lists as it's considerably harder to
  age a page based on the objects used by the slab.

* Process-mapped pages are not easily swappable because there is no easy way to
  map [struct page][page]s to PTEs except by searching every page table which is
  very expensive.

* If the page cache has a large number of process-mapped pages in it, process
  page tables will be walked and pages will be swapped out via
  [swap_out()][swap_out] until enough pages have been freed.

* Regardless, `swap_out()` will have trouble dealing with shared pages - if a
  page is shared a swap entry is allocated, the PTE is filled out with the
  necessary information to find the page in swap again and the reference count
  is decremented. Only when the count reaches 0 will it be freed - pages like
  this are considered to be in the 'swap cache'.

* Page replacement is performed via the the `kswapd` daemon.

## 10.1 Page Replacement Policy

* The page replacement policy is said to be an [LRU][lru]-based algorithm, but
  technically this isn't quite true because the lists are not strictly
  maintained in LRU order.

* The LRU in linux consists of two lists - [active_list][active_list] and
  [inactive_list][inactive_list]. The idea is for the `active_list` to contain
  the [working set][working-set] of all processes and the `inactive_list` to
  contain reclaim candidates.

* Since we store all reclaimable pages in two lists and pages belonging to any
  process may be reclaimed rather than just those belonging to a faulting
  process, the replacement policy is global.

* The lists resemble a simplified [LRU 2Q][lru-q2] (PDF link.) In 2Q, two lists
  are maintained - `Am` and `A1`. `A1` is a FIFO queue and if a page is
  referenced while on that queue they are placed in `Am` which is a normal
  LRU-managed list.

* The 2Q approach is roughly analogous to using [lru_cache_add()][lru_cache_add]
  to place pages on the `inactive_list` (`A1` in the analogy) and using
  [mark_page_accessed()][mark_page_accessed] to move them to the `active_list`
  (`Am` in the analogy.)

* The 2Q algorithm specifies how the size of the two lists have to be tuned but
  linux takes a simpler approach by using [refill_inactive()][refill_inactive]
  to move pages from the bottom of the `active_list` to the `inactive_list` to
  keep `active_list` about two-thirds the size of the total page
  cache. Diagrammatically:

```
                                      -------------------                 -------------------
                                      | activate_page() |                 | lru_cache_add() |
                                      -------------------                 -------------------
                                               |                                   |
                                               |                                   |
                                               v                                   v
                                 -----------------------------     -------------------------------
                                 | add_page_to_active_list() |  /->| add_page_to_inactive_list() |
                                 -----------------------------     -------------------------------
                                               |                |                  |
                                               |                                   |
                                               v                |                  v
                                        ---------------                    -----------------
                                        |  list head  |<------\ |          |   list head   |
    ---------------------               |-------------|       |            |---------------|
    | refill_inactive() |<-\   Page     |             |       | |          |               |
    ---------------------  | removed by | active_list |       |            | inactive_list |
              |               refill_   |             |       | |          |               |
              |            | inactive() |-------------|       |            |---------------|
              v            \ - - - - - -|  list tail  |       | |          |   list tail   |
   -----------------------              ---------------       |            -----------------
   | Move nr_pages pages |                                    | |                  |
   | from active_list to |                                    |                    |
   |    inactive_list    |                                    | |                  v
   -----------------------                                    |             ----------------
              |                                  active_list  | |           | page reclaim |
/------------>|                                   "rotates"   |             ----------------
|             v                                               | |
|   /---------------------\ no       /-------------------\    |
|  /   nr_pages != 0 &&    \------->/ Clear reference bit \---/ |
|  \ active_list has pages /        \     Was it set?     / yes
|   \---------------------/          \-------------------/      |
|             | yes                            | no
|             |                                V                |
|             v                          --------------
|     ------------------                 | nr_pages-- |         |
|     | nr_pages moved |                 --------------
|     |  Job complete  |                       |                |
|     ------------------                       |
|                                              v                |
|                               -------------------------------   page moves to
|                               | del_page_from_active_list() | | inactive_list
\-------------------------------|     Set referenced bit      |-/
                                | add_page_to_inactive_list() |
                                -------------------------------
```

* The list described for 2Q presumes `Am` is an LRU list, but the linux
  equivalent (`active_list`) is more like a [clock algorithm][clock-algorithm]
  where the 'handspread' is the size of the active list.

* When pages reach the bottom of the `active_list` the 'referenced' flag is
  checked. If it's set, the page is moved back to the top of the list and the
  next page is set. If it is cleared, it is moved to the
  `inactive_list`. Regardless of what is done, it is cleared.

* The 'move-to-front' heuristic means that the lists behave in an LRU-_like_
  manner, but there are just too many differences between the linux replacement
  policy and LRU to consider it a 'stack' algorithm.

* Other differences are that the list priority is not order because that would
  require list updates with every reference and the lists are all but ignored
  when paging out from processes because this is decided base on the location of
  the pages in the virtual address space of the process rather than their
  location within the page lists.

* To summarise, the algorithm exhibits LRU-_like_ behaviour and has been shown
  by benchmarks to perform well in practice.

* There are two cases where the algorithm performs badly:

1. When candidates for reclamation are mostly anonymous pages - in this case
   linux will keep on examining a large number of pages before linearly scanning
   process page tables searching for the pages to reclaim. Thankfully this is
   rare.

2. When a single process has a large number of file-backed resident pages in the
   `inactive_list` that are being written to frequently. In this case processes
   and `kswapd` may go into a loop of constantly 'laundering' these pages and
   putting them at the top of the `inactive_list` without freeing anything - in
   this case few pages are moved from the `active_list` to the `inactive_list`.


[dentry]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/dcache.h#L67
[inode]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/fs.h#L438
[lru]:https://en.wikipedia.org/wiki/Cache_algorithms#LRU
[page]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/mm.h#L154
[swap_out]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/vmscan.c#L269

[active_list]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/page_alloc.c#L29
[inactive_list]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/page_alloc.c#L28
[working-set]:https://en.wikipedia.org/wiki/Working_set
[lru-2q]:http://www.vldb.org/conf/1994/P439.PDF
[lru_cache_add]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/swap.c#L58
[mark_page_accessed]: https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/filemap.c#L1332
[refill_inactive]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/vmscan.c#L533
[clock-algorithm]:https://en.wikipedia.org/wiki/Page_replacement_algorithm#Clock
