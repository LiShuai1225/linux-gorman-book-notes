# Chapter 5: Boot Memory Allocator

* It's just not practical to statically initialise all the core kernel memory
  structures at compile-time, because there are too many permutations of
  hardware configurations out there.

* To set up even the most basic structures requires memory - even the physical
  page allocator needs to allocate memory to initialise itself. But how?

* To get around this issue, a specialised allocator called the 'boot memory
  allocator' is used.

* It uses the most basic allocator algorithm - [first fit][first-fit]. This
  means the first available space that can store the requested amount of memory
  is used.

* Additionally the allocator uses a bitmap to represent memory rather than
  linked lists of free blocks. If a bit is 1, the page is allocated, if it is 0,
  it is unallocated.

* To satisfy allocations of sizes smaller than a page, the allocator records the
  Page Frame Number (PFN) - the index of the page, and an offset within that
  page, so subsequent small allocations can be merged together and stored on the
  same page.

* The reason this allocator is not just used as the allocator overall is that,
  despite it not suffering too badly from fragmentation, memory often has to be
  linearly searched to satisfy an allocation. Since bitmaps are being examined,
  the search is expensive and this is made worse by the fact that this algorithm
  tends to leave many small free blocks at the beginning of physical memory
  which are scanned for large allocations, which is very wasteful.

* There are two distinct APIs for the allocator - one for UMA architectures, and
  another for NUMA architectures. The principle difference is that the NUMA API
  requires specification of the node affected by the operation.

* Let's examine the API:

1. [init_bootmem()][init_bootmem] - Initialises the memory between 0 and the
   specified PFN `page` - the beginning of usable memory is at the specified PFN
   `start`. [init_bootmem_node()][init_bootmem_node] is the NUMA equivalent.

2. [reserve_bootmem()][reserve_bootmem] - Marks the pages in the specified range
   reserved. Requests to partially reserve a page will result in the full page
   being reserved. [reserve_bootmem_node()][reserve_bootmem_node] is the NUMA
   equivalent.

3. [free_bootmem()][free_bootmem] - Marks the pages in the specified range
   free. [free_bootmem_node()][free_bootmem_node] is the NUMA equivalent.

4. [alloc_bootmem()][alloc_bootmem] - Allocates specified `size` bytes from
   `ZONE_NORMAL`. The allocation will be aligned to the L1 hardware cache for
   efficiency. [alloc_bootmem_node()][alloc_bootmem_node] is the NUMA
   equivalent. [alloc_bootmem_pages_node()][alloc_bootmem_pages_node] is the
   NUMA equivalent.

5. [alloc_bootmem_low()][alloc_bootmem_low] - Allocates specified `size` bytes
   from `ZONE_DMA`. As with `alloc_bootmem()`, the allocation will be
   L1-aligned. [alloc_bootmem_low_pages_node()][alloc_bootmem_low_pages_node] is
   the NUMA equivalent.

6. [alloc_bootmem_pages()][alloc_bootmem_pages] - Allocates specified `size`
   bytes from `ZONE_NORMAL`, aligned on page size so that full pages will be
   returned to the caller.

7. [alloc_bootmem_low_pages()][alloc_bootmem_low_pages] - Same as
   `alloc_bootmem_pages()` only from `ZONE_DMA`.

8. [bootmem_bootmap_pages()][bootmem_bootmap_pages] - Calculates the number of
   pages required to store a bitmap representing the allocation state of the
   specified `pages` number of pages.

9. [free_all_bootmem()][free_all_bootmem] - Used at the end of the useful life
   of the boot allocator - cycles through all pages in the bitmap. For each that
   is free its flags are cleared and the page is freed to the physical page
   allocator (see chapter 6) so the runtime allocator can set up its free
   lists. [free_all_bootmem_node()][free_all_bootmem_node] is the NUMA
   equivalent.

## 5.1 Representing the Boot Map

* [struct bootmem_data][bootmem_data], typedef-d to `bootmem_data_t`, exists for
  each NUMA node of memory in the system. It contains information needed for the
  boot memory allocator to allocate memory for a node - the bitmap representing
  allocated pages and where the memory is located:

```c
/*
 * node_bootmem_map is a map pointer - the bits represent all physical
 * memory pages (including holes) on the node.
 */
typedef struct bootmem_data {
        unsigned long node_boot_start;
        unsigned long node_low_pfn;
        void *node_bootmem_map;
        unsigned long last_offset;
        unsigned long last_pos;
} bootmem_data_t;
```

* Looking at each field:

1. `node_boot_start` - The starting _physical_ address of the represented block.
2. `node_low_pfn` - The end physical address of the block (LS - likely exclusive
   bound), in other words the end of the `ZONE_NORMAL` this node represents.
3. `node_bootmem_map` - The _virtual_ address of the bitmap representing
   allocated or free pages with each bit.
4. `last_offset` - The offset within the page of the end of the last
   allocation. If 0, the page is full.
5. `last_pos` - The PFN of the page used with the last allocation. Combined with
   `last_offset` a test can be made to see if allocations can be merged into the
   last page rather than needing to allocate a whole new page.

## 5.2 Initialising the Boot Memory Allocator

* Each architecture is required to supply a [setup_arch()][setup_arch] function
  which, among other tasks, is responsible for determining the necessary
  parameters to initialise the boot memory allocator.

* Each architecture additionally has its own function to get the necessary
  parameters. On i386, this is achieved via [setup_memory()][setup_memory] (as
  discussed in 2.2.2.)

* `setup_memory()` calculates the following parameters:

1. `min_low_pfn` - The lowest PFN available in the system.

2. `max_low_pfn` - The highest PFN that may be addressed by low memory
   (`ZONE_NORMAL`.)

3. `highstart_pfn` - This is the PFN of the beginning of high memory
   (`ZONE_HIGHMEM`.)

4. `highend_pfn` - This is the last PFN in high memory.

5. `max_pfn` - This is the last PFN available to the system.

## 5.3 Initialising bootmem_data

* After the limits of usable physical memory are discovered by
  [setup_memory()][setup_memory], one of two boot memory initialisation
  functions is selected and provided with the start and end PFN for the node to
  be initialised.

* [init_bootmem()][init_bootmem], which initialises
  [contig_page_data][contig_page_data], is used by UMA architectures, whereas
  [init_bootmem_node()][init_bootmem_node] is used by NUMA systems to initialise
  a specified node. Both functions are trivial and rely on
  [init_bootmem_core()][init_bootmem_core] to do the real work.

* `init_bootmem_core()` does the following:

1. Inserts the node's [pg_data_t][pg_data_t] into [pgdat_list][pgdat_list] - at
   the end of this function this node is ready for use and needs to be
   established.

2. Records the starting and end address this node in its associated
   [bootmem_data_t][bootmem_data] structure.

3.  Allocates the bitmap representing page allocations. The size (in bytes,
    hence the division by 8) of the bitmap required is calculated as `mapsize =
    (end_pfn - start_pfn + 7)/8`.

4. The bitmap is stored at the _physical_ address pointed to by
   `bootmem_data_t->node_boot_start`, and the _virtual_ address to this map is
   placed in `bootmem_data_t->node_bootmem_map`.

5. Initialises the entire bitmap to 1, effectively marking all pages allocated,
   so in the next step it can determine available memory and mark them
   unallocated hence available.

6. On i386, [register_bootmem_low_pages()][register_bootmem_low_pages] is used
   to read through the [e820 map][e820], calling [free_bootmem()][free_bootmem]
   for each usable page to set the bit 0 (marking it available for allocation),
   before calling [reserve_bootmem()][reserve_bootmem] to reserve the pages
   needed by the actual bitmap itself.

[first-fit]:http://www.memorymanagement.org/mmref/alloc.html#mmref-alloc-first-fit
[init_bootmem]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L304
[reserve_bootmem]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L311
[free_bootmem]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L316
[alloc_bootmem]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L326
[alloc_bootmem_low]:http://fxr.watson.org/fxr/source/include/linux/bootmem.h?v=linux-2.4.22#L40
[alloc_bootmem_pages]:http://fxr.watson.org/fxr/source/include/linux/bootmem.h?v=linux-2.4.22#L42
[alloc_bootmem_low_pages]:http://fxr.watson.org/fxr/source/include/linux/bootmem.h?v=linux-2.4.22#L44
[bootmem_bootmap_pages]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L32
[free_all_bootmem]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L321
[init_bootmem_node]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L284
[reserve_bootmem_node]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L289
[free_bootmem_node]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L294
[alloc_bootmem_node]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L344
[alloc_bootmem_pages_node]:http://fxr.watson.org/fxr/source/include/linux/bootmem.h?v=linux-2.4.22#L55
[alloc_bootmem_low_pages_node]:http://fxr.watson.org/fxr/source/include/linux/bootmem.h?v=linux-2.4.22#L57
[free_all_bootmem_node]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L299

[bootmem_data]:http://fxr.watson.org/fxr/source/include/linux/bootmem.h?v=linux-2.4.22#L25

[setup_arch]:http://fxr.watson.org/fxr/source/arch/i386/kernel/setup.c?v=linux-2.4.22#L1124
[setup_memory]:http://fxr.watson.org/fxr/source/arch/i386/kernel/setup.c?v=linux-2.4.22#L991

[contig_page_data]:http://fxr.watson.org/fxr/source/mm/numa.c?v=linux-2.4.22#L15
[init_bootmem_core]:http://fxr.watson.org/fxr/source/mm/bootmem.c?v=linux-2.4.22#L46
[pg_data_t]:http://fxr.watson.org/fxr/source/include/linux/mmzone.h?v=linux-2.4.22#L129
[pgdat_list]:http://fxr.watson.org/fxr/source/mm/page_alloc.c?v=linux-2.4.22#L30
[register_bootmem_low_pages]:http://fxr.watson.org/fxr/source/arch/i386/kernel/setup.c?v=linux-2.4.22#L954
[e820]:https://en.wikipedia.org/wiki/E820
