# Chapter 11: Swap Management

* Just as linux uses free memory for buffering data from a disk, the reverse is
  true as well - eventually there's a need to free up private or anonymous pages
  used by a process. The pages are copied to backing storage, sometimes called
  the 'swap area'.

* Strictly speaking, linux doesn't swap because 'swapping' refers to copying an
  entire process address space to disk and 'paging' to copying out individual
  pages, however it's referred to as 'swapping' in discussion and documentation
  so we'll call it swapping regardless.

* There are 2 principal reasons for the existence of swap space:

1. It expands the amount of memory a process may use - virtual memory and swap
   space allows a large process to run even if the process is only partially
   resident. Because old pages may be swapped out, the amount of memory
   addressed may easily exceed RAM because demand paging will ensure the pages
   are reloaded if necessary.

2. Even if sufficient memory, swap is useful - a significant number of pages
   referenced by a process early on in its life may only be used for
   initialisation then never used again. It's better to swap out these pages and
   create more disk buffers than leave them resident and unused.

* Swap is slow. Very slow as disks are slow (relatively to memory) - if
  processes are _frequently_ addressing a large amount of memory no amount of
  swap or fast disks will make it run without a reasonable time, only more RAM
  can help.

* It's very important that the correct page be swapped out (as discussed in
  chapter 10), and also that related pages be stored close together in the swap
  space so they are likely to be swapped in at the same time while reading
  ahead.

## 11.1 Describing the Swap Area

* Each active swap area has a [struct swap_info_struct][swap_info_struct]
  describing the area:

```c
/*
 * The in-memory structure used to track swap areas.
 */
struct swap_info_struct {
        unsigned int flags;
        kdev_t swap_device;
        spinlock_t sdev_lock;
        struct dentry * swap_file;
        struct vfsmount *swap_vfsmnt;
        unsigned short * swap_map;
        unsigned int lowest_bit;
        unsigned int highest_bit;
        unsigned int cluster_next;
        unsigned int cluster_nr;
        int prio;                       /* swap priority */
        int pages;
        unsigned long max;
        int next;                       /* next entry on swap list */
};
```

* All the `swap_info_struct`s in the running system are stored in a statically
  declared array, [swap_info][swap_info] which holds
  [MAX_SWAPFILES][MAX_SWAPFILES] (defined as 32) - this means that at most 32
  swap areas can exist on a running system.

* Looking at each field:

1. `flags` - A bit field with 2 possible values - [SWP_USED][SWP_USED] (`0b01`)
   and [SWP_WRITEOK][SWP_WRITEOK] (`0b11`). `SWP_USED` implies the swap area is
   currently active, and `SWP_WRITEOK` when linux is ready to write to the
   area. `SWP_WRITEOK` contains `SWP_USED` as the former implies the latter must
   be the case.

2. `swap_device` - The device corresponding to the partition for this swap
   area. If the swap area is a file, this is set to `NULL`.

3. `sdev_lock` - - Spinlock protecting the struct, most pertinently
   `swap_map`. It's locked and unlocked via
   [swap_device_lock()][swap_device_lock] and
   [swap_device_unlock()][swap_device_unlock].

4. `swap_file` - The [struct dentry][dentry] for the actual special file that is
   mounted as a swap area, for example this file may exist in `/dev` in the case
   that a partition is mounted. This field is needed to identify the correct
   `swap_info_struct` when deactivating a swap area.

5. `swap_vfsmnt` - The [struct vfsmount][vfsmount] object corresponding to where
   the device or file for this swap area is located.

6. `swap_map` - A large array containing one entry for every swap entry or
   page-sized slot in the area. An 'entry' is a reference count of the number of
   users of the page slot, with the swap cache counting as one user and every
   PTE that has been paged out to the slot as the other users. If the entry is
   equal to [SWAP_MAP_MAX][SWAP_MAP_MAX], the slot is allocated permanently. If
   it's equal to [SWAP_MAP_BAD][SWAP_MAP_BAD], the slot will never be used.

7. `lowest_bit` - Lowest possible free slot available in the swap area and is
   used to start from when linearly scanning to reduce the search space - there
   are definitely no free slots below this mark.

8. `highest_bit` - Highest possible free slot available. Similar to
   `lowest_bit`, there are definitely no free slots above this mark.

9. `cluster_next` - Offset of the next cluster of blocks to use. The swap area
   tries to have pages allocated in cluster blocks to increase the chance
   related pages will be stored together.

10. `cluster_nr` - Number of pages left to allocate in this cluster.

11. `prio` - The 'priority' of the swap area - this determines how likely the
    area is to be used. By default the priorities are arranged in order of
    activation, but the sysadmin may also specify it using the `-p` flag of
    [swapon][swapon].

12. `pages` - Because some slots on the swap file may be unusable, this field
    stores the number of usable pages in the swap area. This differs from `max`
    in that swaps marked [SWAP_MAP_BAD][SWAP_MAP_BAD] are not counted.

13. `max` - Total number of slots in this swap area.

14. `next` - The index in the [swap_info][swap_info] array of the next swap area
    in the system.

* The areas are not only stored in an array, they are also kept in a
  [struct swap_list_t][swap_list_t] 'pseudolist'
  [swap_list][swap_list]. `swap_list_t` is a simple type:

```c
struct swap_list_t {
        int head;       /* head of priority-ordered swapfile list */
        int next;       /* swapfile to be used next */
};
```

* `head` is the index of the swap area of the highest priority swap area in use,
  and `next` is the index of the next swap area that should be used.

* This list enables areas to be looked up in order of priority when necessary
  but still remain easily looked up in the `swap_info` array.

* Each swap area is divided into a number of page-sized slots on disk (e.g. 4KiB
  each on i386.)

* The first slot is always reserved because it contains information about the
  swap area that must not be overwritten, including the first 1KiB which stores
  a disk label for the partition that can be retrieved via userspace tools.

* The remaining space in this initial slot is used for information about the
  swap area which is filled when the swap area is created with
  [mkswap][mkswap]. This is represented by the [union swap_header][swap_header]
  union:

```c
/*
 * Magic header for a swap area. The first part of the union is
 * what the swap magic looks like for the old (limited to 128MB)
 * swap area format, the second part of the union adds - in the
 * old reserved area - some extra information. Note that the first
 * kilobyte is reserved for boot loader or disk label stuff...
 *
 * Having the magic at the end of the PAGE_SIZE makes detecting swap
 * areas somewhat tricky on machines that support multiple page sizes.
 * For 2.5 we'll probably want to move the magic to just beyond the
 * bootbits...
 */
union swap_header {
        struct
        {
                char reserved[PAGE_SIZE - 10];
                char magic[10];                 /* SWAP-SPACE or SWAPSPACE2 */
        } magic;
        struct
        {
                char         bootbits[1024];    /* Space for disklabel etc. */
                unsigned int version;
                unsigned int last_page;
                unsigned int nr_badpages;
                unsigned int padding[125];
                unsigned int badpages[1];
        } info;
};
```

* Looking at each of the fields:

1. `reserved` - Dummy field used to position `magic` correctly at the end of the
   page.

2. `magic` - Used for identifying the magic string that identifies a swap
   header - this is in place to ensure that a partition that is not a swap area
   will never be used by mistake, and to determine what version of swap area is
   to be used - if the string is `"SWAP-SPACE"`, then it's version 1 of the swap
   file format. If it's `"SWAPSPACE2"`, then version 2 will be used.

3. `bootbits` - Reserved area containing information about the partition such as
   the disk label, retrievable via userspace tools.

4. `version` - Version of the swap area layout.

5. `last_page` - Last usable page in the area.

6. `nr_badpages` - Known number of bad pages that exist in the swap area.

7. `padding` - Disk sectors are usually 512 bytes in size. `version`,
   `last_page` and `nr_badpages` take up 12 bytes, so this field takes up the
   remaining 500 bytes to sector-align `badpages`.

8. `badpages` - The remainder of the page is used to store the indices of up to
   [MAX_SWAP_BADPAGES][MAX_SWAP_BADPAGES] number of bad page slots. These are
   filled in by the [mkswap][mkswap] userland tool if the `-c` switch is
   specified to check the area.

* `MAX_SWAP_BADPAGES` is a compile-time constant that varies if the struct
  changes, but is 637 entries in its current form determined by:

```
MAX_SWAP_BADPAGES = (PAGE_SIZE - <bootblock size = 1024> - <padding size = 512> -
                     <magic string size = 10>)/sizeof(long)
```

[swap_info_struct]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L64
[swap_info]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/swapfile.c#L32
[MAX_SWAPFILES]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L11
[SWP_USED]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L53
[SWP_WRITEOK]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L54
[swap_device_lock]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L210
[swap_device_unlock]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L211
[dentry]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/dcache.h#L67
[vfsmount]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/mount.h#L19
[SWAP_MAP_MAX]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L58
[SWAP_MAP_BAD]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L59
[swapon]:http://man7.org/linux/man-pages/man8/swapon.8.html
[swap_list]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/mm/swapfile.c#L30
[swap_list_t]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L153
[mkswap]:http://man7.org/linux/man-pages/man8/mkswap.8.html
[swap_header]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L25
[MAX_SWAP_BADPAGES]:https://github.com/lorenzo-stoakes/linux-historical/blob/v2.4.22/include/linux/swap.h#L48
