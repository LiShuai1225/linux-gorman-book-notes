# Chapter 7: Non-contiguous Memory Allocation

* When dealing with large amounts of memory it is better if possible to use
  physically contiguous pages both in terms of caching and memory access latency.

* Unfortunately this is not always possible due to external fragmentation
  problems with the binary buddy allocator (LS - I thought internal
  fragmentation was more the problem for the binary buddy system? Also is this
  the only cause of non-contiguous pages?)

* Linux provides a means for non-contiguous physical memory to be used in
  contiguous virtual memory via [vmalloc()][vmalloc].

* When `vmalloc()` is used, an area is reserved in the virtual address space
  between [VMALLOC_START][VMALLOC_START] and [VMALLOC_END][VMALLOC_END] - the
  location of `VMALLOC_START` varies depending on the amount of available
  physical memory, but the region will be at least
  [VMALLOC_RESERVE][VMALLOC_RESERVE] (aliased to
  [__VMALLOC_RESERVE][__VMALLOC_RESERVE]) in size, which on i386 is 128MiB - the
  exact size of the region was discussed in more detail in section 4.1

* The page tables in this region are adjusted as needed to point to physical
  pages which are allocated with the normal physical page allocator - this means
  that allocation _has_ to be a multiple of the hardware page size.

* Because performing allocations this way require modifications to be made to
  the kernel page tables, there is a limitation on how much memory can be mapped
  with `vmalloc()` because only the virtual address space between
  `VMALLOC_START` and `VMALLOC_END` is available.

* Because of the limited nature of `vmalloc()`, it is used sparingly in the core
  kernel - in fact in 2.4.22 it is only used for storing swap map information
  (see chapter 11) and for loading kernel modules into memory.

## 7.1 Describing Virtual Memory Areas

* The vmalloc address space is managed with a 'resource map
  allocator'. [struct vm_struct][vm_struct] is used for storing the base, size
  pairs for this allocator and is defined as follows:

```c
struct vm_struct {
        unsigned long flags;
        void * addr;
        unsigned long size;
        struct vm_struct * next;
};
```

* In theory a fully-fledged VMA count have been used, but a VMA contains more
  information that doesn't apply to vmalloc areas and so doing that would be
  wasteful.

* Looking at each field:

1. `flags` - Either set to `VM_ALLOC` if used with [vmalloc()][vmalloc] or
   `VM_IOREMAP` when [ioremap()][ioremap] is used to map high memory into the
   kernel virtual address space.

2. `addr` - Starting address of the memory block.

3. `size` - Size in bytes.

4. `next` - Pointer to the next `vm_struct`, these are ordered by address and
   the list is protected by the [vmlist_lock][vmlist_lock] lock.

* Each area is separated by at least one page to protect against overruns:

```
------------------------------------------------------/\/\
|  vmalloc   | Page |  vmalloc   | Page |  vmalloc   |    |
| Allocation | Gap  | Allocation | Gap  | Allocation |    |
------------------------------------------------------/\/\
^                                                         ^
| VMALLOC_START                               VMALLOC_END |
```

* When the kernel wants to allocate a new area, the `vm_struct` list is searched
  linearly via [get_vm_area()][get_vm_area].

* Space for the struct is allocated with [kmalloc()][kmalloc].

* When the virtual area is used for remapping an area for I/O (known as
  'ioremapping'), `get_vm_area()` will be called directly to map the requested
  area.

[vmalloc]:http://fxr.watson.org/fxr/source/include/linux/vmalloc.h?v=linux-2.4.22#L37
[VMALLOC_START]:http://fxr.watson.org/fxr/source/include/asm-i386/pgtable.h?v=linux-2.4.22#L161
[VMALLOC_END]:http://fxr.watson.org/fxr/source/include/asm-i386/pgtable.h?v=linux-2.4.22#L165
[VMALLOC_RESERVE]:http://fxr.watson.org/fxr/source/include/asm-i386/page.h?v=linux-2.4.22#L129
[__VMALLOC_RESERVE]:http://fxr.watson.org/fxr/source/include/asm-i386/page.h?v=linux-2.4.22#L87

[vm_struct]:http://fxr.watson.org/fxr/source/include/linux/vmalloc.h?v=linux-2.4.22#L15
[ioremap]:http://fxr.watson.org/fxr/source/include/asm-i386/io.h?v=linux-2.4.22#L122
[vmlist_lock]:http://fxr.watson.org/fxr/source/include/linux/vmalloc.h?v=linux-2.4.22#L64
[get_vm_area]:http://fxr.watson.org/fxr/source/mm/vmalloc.c?v=linux-2.4.22#L195
[kmalloc]:http://fxr.watson.org/fxr/source/mm/slab.c?v=linux-2.4.22#L1555
